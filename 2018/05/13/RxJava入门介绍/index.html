
 <!DOCTYPE HTML>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  
    <title>RxJava入门介绍 | 秋日私语</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="秋日私语">
    

    
    <meta name="description" content="简介什么是RxJava？一个词：异步。  RxJava 在 GitHub 主页上的自我介绍是”A library for composing asynchronous and event-based programs using observable sequences for the Java VM”(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)，这就是 RxJ">
<meta name="keywords" content="软件开发">
<meta property="og:type" content="article">
<meta property="og:title" content="RxJava入门介绍">
<meta property="og:url" content="http://yoursite.com/2018/05/13/RxJava入门介绍/index.html">
<meta property="og:site_name" content="秋日私语">
<meta property="og:description" content="简介什么是RxJava？一个词：异步。  RxJava 在 GitHub 主页上的自我介绍是”A library for composing asynchronous and event-based programs using observable sequences for the Java VM”(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)，这就是 RxJ">
<meta property="og:locale" content="zh">
<meta property="og:image" content="e:/资料库/工作资料/随笔记录/杂货铺/observer-pattern.jpg">
<meta property="og:image" content="e:/资料库/工作资料/随笔记录/杂货铺/RxJava-observer-pattern.jpg">
<meta property="og:image" content="e:/资料库/工作资料/随笔记录/杂货铺/subscribe-on.jpg">
<meta property="og:image" content="e:/资料库/工作资料/随笔记录/杂货铺/observe-on.jpg">
<meta property="og:image" content="e:/资料库/工作资料/随笔记录/杂货铺/complex-scheduler.jpg">
<meta property="og:updated_time" content="2018-08-24T01:51:18.563Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxJava入门介绍">
<meta name="twitter:description" content="简介什么是RxJava？一个词：异步。  RxJava 在 GitHub 主页上的自我介绍是”A library for composing asynchronous and event-based programs using observable sequences for the Java VM”(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)，这就是 RxJ">
<meta name="twitter:image" content="e:/资料库/工作资料/随笔记录/杂货铺/observer-pattern.jpg">

    
    <link rel="alternative" href="/atom.xml" title="秋日私语" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="秋日私语" title="秋日私语"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="秋日私语">秋日私语</a></h1>
				<h2 class="blog-motto">落霞与孤鹜齐飞，秋水共长天一色。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/13/RxJava入门介绍/" title="RxJava入门介绍" itemprop="url">RxJava入门介绍</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="秋日私语" target="_blank" itemprop="author">秋日私语</a>
		
  <p class="article-time">
    <time datetime="2018-05-13T00:00:00.000Z" itemprop="datePublished"> Published 2018-05-13</time>
  </p>
  
  <p>
	  <span id="busuanzi_container_page_pv">
	      总阅读<span id="busuanzi_value_page_pv"></span>次
	  </span>
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-介绍和原理简析"><span class="toc-number">2.</span> <span class="toc-text">API 介绍和原理简析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概念：扩展的观察者模式"><span class="toc-number">2.1.</span> <span class="toc-text">1.  概念：扩展的观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-基本实现"><span class="toc-number">2.2.</span> <span class="toc-text">2. 基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-创建-Observer"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 创建 Observer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-创建-Observable"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 创建 Observable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Subscribe-订阅"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 Subscribe (订阅)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-使用示例"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程控制-Scheduler"><span class="toc-number">2.3.</span> <span class="toc-text">3. 线程控制(Scheduler)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Scheduler-的-API"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 Scheduler 的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Scheduler的原理"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 Scheduler的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-变换"><span class="toc-number">2.4.</span> <span class="toc-text">4.变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-API"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-变换的原理-lift"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 变换的原理(lift)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-compose-对-Observable-整体的变换"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 compose: 对 Observable 整体的变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-线程控制：Scheduler"><span class="toc-number">2.5.</span> <span class="toc-text">5. 线程控制：Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Scheduler的API"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 Scheduler的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Scheduler的原理"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 Scheduler的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-延伸：doOnSubscribe"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3 延伸：doOnSubscribe()</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<script src="\assets\js\APlayer.min.js"> </script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>什么是RxJava？一个词：异步。</p>
<blockquote>
<p>RxJava 在 GitHub 主页上的自我介绍是”A library for composing asynchronous and event-based programs using observable sequences for the Java VM”(一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库)，这就是 RxJava。</p>
</blockquote>
<p>RxJava的优点：一个词：简洁。</p>
<p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。Android创造的AsyncTask和Handler，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。</p>
<p>一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.run(); </span><br><span class="line">        <span class="keyword">for</span> (File folder : folders) &#123; </span><br><span class="line">            File[] files = folder.listFiles(); </span><br><span class="line">            <span class="keyword">for</span> (File file : files) &#123; </span><br><span class="line">                <span class="keyword">if</span> (file.getName().endsWith(<span class="string">".png"</span>)) &#123; </span><br><span class="line">                    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromFile(file); </span><br><span class="line">                    getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123; </span><br><span class="line">                        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </span><br><span class="line">                            imageCollectorView.addImage(bitmap); </span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;); </span><br><span class="line">                    &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p>
<p>而如果使用 RxJava ，实现方式是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(folders)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Observable&lt;File&gt; <span class="title">call</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Observable.from(file.listFiles()); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;) </span><br><span class="line">    .filter(<span class="keyword">new</span> Func1&lt;File, Boolean&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> file.getName().endsWith(<span class="string">".png"</span>); &#125; &#125;</span><br><span class="line">    ) </span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;File, Bitmap&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> getBitmapFromFile(file); &#125; &#125;</span><br><span class="line">        ) </span><br><span class="line">    .subscribeOn(Schedulers.io()) </span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; </span><br><span class="line">            imageCollectorView.addImage(bitmap); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的，当需求变得复杂时，这种优势将更加明显。</p>
<p>另外，如果你的IDE是AndroidStudio ，其实每次打开某个Java文件的时候，你会看到被自动Lambda化的预览，这将让你更加清晰地看到程序逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(folders) </span><br><span class="line">    .flatMap((Func1) (folder) -&gt; &#123; Observable.from(file.listFiles()) &#125;) </span><br><span class="line">    .filter((Func1) (file) -&gt; &#123; file.getName().endsWith(<span class="string">".png"</span>) &#125;) </span><br><span class="line">    .map((Func1) (file) -&gt; &#123; getBitmapFromFile(file) &#125;) </span><br><span class="line">    .subscribeOn(Schedulers.io()) </span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) </span><br><span class="line">    .subscribe((Action1) (bitmap) -&gt; &#123;imageCollectorView.addImage(bitmap) &#125;);</span><br></pre></td></tr></table></figure>
<p>所以， RxJava 好在哪？就好在简洁，好在那把什么复杂逻辑都能穿成一条线的简洁。</p>
<h2 id="API-介绍和原理简析"><a href="#API-介绍和原理简析" class="headerlink" title="API 介绍和原理简析"></a>API 介绍和原理简析</h2><h3 id="1-概念：扩展的观察者模式"><a href="#1-概念：扩展的观察者模式" class="headerlink" title="1.  概念：扩展的观察者模式"></a>1.  概念：扩展的观察者模式</h3><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p>
<p><img src="E:\资料库\工作资料\随笔记录\杂货铺\observer-pattern.jpg" alt="observer-pattern"></p>
<p>而 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。</p>
<p>RxJava的观察者模式：</p>
<p>RxJava 有四个基本概念：Observable(可观察者，即被观察者)、 Observer(观察者)、 subscribe(订阅)、事件Observable和Observer通过 subscribe()方法实现订阅关系，从而 Observable可以在需要的时候发出事件来通知 Observer。与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 onNext()（相当于 onClick() / onEvent()）之外，还定义了两个特殊的事件：onCompleted()和 onError()。</p>
<ul>
<li>onCompleted(): 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的onNext()发出时，需要触发 onCompleted()方法作为标志。</li>
<li>onError(): 事件队列异常。在事件处理过程中出异常时，onError()会被触发，同时队列自动终止，不允许再有事件发出。</li>
<li>在一个正确运行的事件序列中, onCompleted()和 onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted()和 onError()二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</li>
</ul>
<p>RxJava 的观察者模式大致如下图：</p>
<p><img src="E:\资料库\工作资料\随笔记录\杂货铺\RxJava-observer-pattern.jpg" alt="RxJava-observer-pattern"></p>
<h3 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2. 基本实现"></a>2. 基本实现</h3><p>基于以上的概念， RxJava 的基本实现主要有三点：</p>
<h4 id="2-1-创建-Observer"><a href="#2-1-创建-Observer" class="headerlink" title="2.1 创建 Observer"></a>2.1 创建 Observer</h4><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 Observer接口的实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = <span class="keyword">new</span> Observer&lt;String&gt;() &#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">            Log.d(tag, <span class="string">"Item: "</span> + s); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            Log.d(tag, <span class="string">"Completed!"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; </span><br><span class="line">            Log.d(tag, <span class="string">"Error!"</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>除了 Observer接口之外，RxJava 还内置了一个实现了 Observer的抽象类：Subscriber。Subscriber对 Observer接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">        Log.d(tag, <span class="string">"Item: "</span> + s); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Log.d(tag, <span class="string">"Completed!"</span>); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; </span><br><span class="line">        Log.d(tag, <span class="string">"Error!"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，Observer也总是会先被转换成一个 Subscriber再使用。所以如果你只想使用基本功能，选择 Observer 和 Subscriber是完全一样的。它们的区别对于使用者来说主要有两点：</p>
<ul>
<li>onStart()：这是 Subscriber增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。</li>
<li>unsubscribe()： 这是 Subscriber所实现的另一个接口 Subscription的方法，用于取消订阅。在这个方法被调用后，Subscriber将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed()先判断一下状态。 unsubscribe()这个方法很重要，因为在subscribe()之后， Observable会持有 Subscriber的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop()等方法中）调用 unsubscribe()来解除引用关系，以避免内存泄露的发生。</li>
</ul>
<h4 id="2-2-创建-Observable"><a href="#2-2-创建-Observable" class="headerlink" title="2.2 创建 Observable"></a>2.2 创建 Observable</h4><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create()方法来创建一个 Observable ，并为它定义事件触发规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123; </span><br><span class="line">        subscriber.onNext(<span class="string">"Hello"</span>); </span><br><span class="line">        subscriber.onNext(<span class="string">"Rx"</span>); </span><br><span class="line">        subscriber.onNext(<span class="string">"Java"</span>); </span><br><span class="line">        subscriber.onCompleted(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，这里传入了一个 OnSubscribe对象作为参数。OnSubscribe会被存储在返回的 Observable对象中，它的作用相当于一个计划表，当 Observable被订阅的时候，OnSubscribe的 call()方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber将会被调用三次 onNext()和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p>
<p>create()方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p>
<ul>
<li><p>just(T…): 将传入的参数依次发送出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"RxJava"</span>);</span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("RxJava");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>from(T[])/ from(Iterable&lt;? extends T&gt;) : 将传入的数组或 Iterable拆分成具体对象后，依次发送出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;<span class="string">"Hello"</span>, <span class="string">"Hi"</span>, <span class="string">"RxJava"</span>&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br><span class="line"><span class="comment">// 将会依次调用：</span></span><br><span class="line"><span class="comment">// onNext("Hello");</span></span><br><span class="line"><span class="comment">// onNext("Hi");</span></span><br><span class="line"><span class="comment">// onNext("RxJava");</span></span><br><span class="line"><span class="comment">// onCompleted();</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面 just(T…)的例子和 from(T[])的例子，都和之前的 create(OnSubscribe)的例子是等价的。</p>
<h4 id="2-3-Subscribe-订阅"><a href="#2-3-Subscribe-订阅" class="headerlink" title="2.3 Subscribe (订阅)"></a>2.3 Subscribe (订阅)</h4><p>创建了 Observable和 Observer之后，再用 subscribe()方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有人可能会注意到，subscribe()这个方法有点怪：它看起来是『observalbe订阅了 observer/ subscriber』而不是『observer /subscriber订阅了 observalbe』，<br>这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成observer.subscribe(observable)/ subscriber.subscribe(observable)<br>，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p>
</blockquote>
<p>Observable.subscribe(Subscriber)的内部实现是这样的（仅核心代码）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123; </span><br><span class="line">    subscriber.onStart(); </span><br><span class="line">    onSubscribe.call(subscriber); </span><br><span class="line">    <span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，subscriber()做了3件事：</p>
<ol>
<li>调用 Subscriber.onStart() 。这个方法在前面已经介绍过，是一个可选的准备方法。</li>
<li>调用 Observable中的 OnSubscribe.call(Subscriber)。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中，Observable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。</li>
<li>将传入的 Subscriber作为 Subscription返回。这是为了方便 unsubscribe()。</li>
</ol>
<p>除了 subscribe(Observer)和 subscribe(Subscriber)，subscribe()还支持不完整定义的回调，RxJava 会自动根据定义创建出Subscriber。形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123; </span><br><span class="line">    <span class="comment">// onNext() </span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">        Log.d(tag, s); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123; </span><br><span class="line">    <span class="comment">// onError() </span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// Error handling </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Action0 onCompletedAction = <span class="keyword">new</span> Action0() &#123; </span><br><span class="line">    <span class="comment">// onCompleted() </span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Log.d(tag, <span class="string">"completed"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span></span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure>
<p>Action0是 RxJava 的一个接口，它只有一个方法 call()，这个方法是无参无返回值的；由于 onCompleted()方法也是无参无返回值的，因此 Action0可以被当成一个包装对象，将 onCompleted()的内容打包起来将自己作为一个参数传入 subscribe()以实现不完整定义的回调。这样其实也可以看做将 onCompleted()方法作为参数传进了subscribe()，相当于其他某些语言中的『闭包』。 Action1也是一个接口，它同样只有一个方法 call(T param)，这个方法也无返回值，但有一个参数；与 Action0同理，由于 onNext(T obj)和 onError(Throwable error)也是单参数无返回值的，因此 Action1可以将onNext(obj)和 onError(error)打包起来传入 subscribe()以实现不完整定义的回调。事实上，虽然 Action0和 Action1在 API 中使用最广泛，但 RxJava 是提供了多个 ActionX形式的接口 (例如 Action2, Action3) 的，它们可以被用以包装不同的无返回值的方法。</p>
<h4 id="2-4-使用示例"><a href="#2-4-使用示例" class="headerlink" title="2.4 使用示例"></a>2.4 使用示例</h4><p>a. 打印字符串数组</p>
<p>将字符串数组 names中的所有字符串依次打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observable.from(names) </span><br><span class="line">  .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123; </span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">          Log.d(tag, name); </span><br><span class="line">      &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>b. 由 id 取得图片并显示</p>
<p>由指定的一个 drawable 文件 id drawableRes取得图片，并显示在 ImageView中，并在出现异常的时候打印 Toast 报错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123; </span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes)); </span><br><span class="line">        subscriber.onNext(drawable); subscriber.onCompleted(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123; </span><br><span class="line">        imageView.setImageDrawable(drawable); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; </span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>正如上面两个例子这样，创建出 Observable和 Subscriber，再用 subscribe()将它们串起来，一次 RxJava 的基本使用就完成了。然而，在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念：Scheduler。</p>
<h3 id="3-线程控制-Scheduler"><a href="#3-线程控制-Scheduler" class="headerlink" title="3. 线程控制(Scheduler)"></a>3. 线程控制(Scheduler)</h3><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 subscribe()，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 Scheduler（调度器）。</p>
<h4 id="3-1-Scheduler-的-API"><a href="#3-1-Scheduler-的-API" class="headerlink" title="3.1 Scheduler 的 API"></a>3.1 Scheduler 的 API</h4><p>在RxJava 中，Scheduler ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 Scheduler ，它们已经适合大多数的使用场景：</p>
<ul>
<li>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>
<li>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</li>
<li>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。、</li>
<li>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</li>
<li>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</li>
</ul>
<p>有了这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 <em> subscribeOn(): 指定 subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程。 </em> observeOn(): 指定 Subscriber 所运行在的线程。或者叫做事件消费的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer number)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"number:"</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>上面这段代码中，由于 subscribeOn(Schedulers.io()) 的指定，被创建的事件的内容 1、2、3、4 将会在 IO 线程发出；而由于 observeOn(AndroidScheculers.mainThread()) 的指定，因此 subscriber 数字的打印将发生在主线程 。事实上，这种在 subscribe() 之前写上两句 subscribeOn(Scheduler.io()) 和 observeOn(AndroidSchedulers.mainThread()) 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p>
<p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io()) <span class="comment">// 指定 subscribe() 发生在 IO 线程</span></span><br><span class="line">.observeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定 Subscriber 的回调发生在主线程</span></span><br><span class="line">.subscribe(<span class="keyword">new</span> Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Drawable drawable)</span> </span>&#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(activity, <span class="string">"Error!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p>
<h4 id="3-2-Scheduler的原理"><a href="#3-2-Scheduler的原理" class="headerlink" title="3.2 Scheduler的原理"></a>3.2 Scheduler的原理</h4><p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 subscribe() 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p>
<h3 id="4-变换"><a href="#4-变换" class="headerlink" title="4.变换"></a>4.变换</h3><p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</p>
<h4 id="4-1-API"><a href="#4-1-API" class="headerlink" title="4.1 API"></a>4.1 API</h4><p>首先看一个 map() 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"images/logo.png"</span>) <span class="comment">// 输入类型 String</span></span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这里出现了一个叫做 Func1 的类。它和 Action1 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 Func1 和 Action 的区别在于， Func1 包装的是有返回值的方法。另外，和 ActionX 一样， FuncX 也有多个，用于不同参数个数的方法。FuncX 和 ActionX 的区别在 FuncX 包装的是有返回值的方法。</p>
<p>可以看到，map() 方法将参数中的 String 对象转换成一个 Bitmap 对象后返回，而在经过 map() 方法后，事件的参数类型也由 String 转为了 Bitmap。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。</p>
<ul>
<li>map(): 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。</li>
<li>flatMap(): 这是一个很有用但非常难理解的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;Student, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> student.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Student&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        List&lt;Course&gt; courses = student.getCourses();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; courses.size(); i++) &#123;</span><br><span class="line">            Course course = courses.get(i);</span><br><span class="line">            Log.d(tag, course.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure></p>
<p>依然很简单。那么如果我不想在 Subscriber 中使用 for 循环，而是希望 Subscriber 中直接传入单个的 Course 对象呢（这对于代码复用很重要）？用 map() 显然是不行的，因为 map() 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p>
<p>这个时候，就需要用 flatMap() 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出， flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 map() 不同的是， flatMap() 中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。 flatMap() 的原理是这样的：1. 使用传入的事件对象创建一个 Observable 对象；2. 并不发送这个 Observable, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 flatMap() 所谓的 flat。</p>
<h4 id="4-2-变换的原理-lift"><a href="#4-2-变换的原理-lift" class="headerlink" title="4.2 变换的原理(lift)"></a>4.2 变换的原理(lift)</h4><p>这些变换虽然功能各有不同，但实质上都是针对事件序列的处理和再发送。而在 RxJava 的内部，它们是基于同一个基础的变换方法： lift(Operator)。首先看一下 lift() 的内部实现（仅核心代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span></span><br><span class="line"><span class="comment">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;R&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">            Subscriber newSubscriber = operator.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            onSubscribe.call(newSubscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很有意思：它生成了一个新的 Observable 并返回，而且创建新 Observable 所用的参数 OnSubscribe 的回调方法 call() 中的实现竟然看起来和前面讲过的 Observable.subscribe() 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 onSubscribe.call(subscriber) 中的 onSubscribe 所指代的对象不同：</p>
<ul>
<li>subscribe() 中这句话的 onSubscribe 指的是 Observable 中的 onSubscribe 对象，这个没有问题，但是 lift() 之后的情况就复杂了点。</li>
<li>当含有 lift() 时：<ol>
<li>lift() 创建了一个 Observable 后，加上之前的原始 Observable，已经有两个 Observable 了；</li>
<li>而同样地，新 Observable 里的新 OnSubscribe 加上之前的原始 Observable 中的原始 OnSubscribe，也就有了两个 OnSubscribe；</li>
<li>当用户调用经过 lift() 后的 Observable 的 subscribe() 的时候，使用的是 lift() 所返回的新的 Observable ，于是它所触发的 onSubscribe.call(subscriber)，也是用的新 Observable 中的新 OnSubscribe，即在 lift() 中生成的那个 OnSubscribe； </li>
<li>而这个新 OnSubscribe 的 call() 方法中的 onSubscribe ，就是指的原始 Observable 中的原始 OnSubscribe ，在这个 call() 方法里，新 OnSubscribe 利用 operator.call(subscriber) 生成了一个新的 Subscriber（Operator 就是在这里，通过自己的 call() 方法将新 Subscriber 和原始 Subscriber 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 Subscriber 向原始 Observable 进行订阅。这样就实现了 lift() 过程，有点像一种代理机制，通过事件拦截和处理实现事件序列的变换。</li>
</ol>
</li>
</ul>
<p>精简掉细节的话，也可以这么说：在 Observable 执行了 lift(Operator) 方法之后，会返回一个新的 Observable，这个新的 Observable 会像一个代理一样，负责接收原始的 Observable 发出的事件，并在处理后发送给 Subscriber。</p>
<p>举一个具体的 Operator 的实现。下面这是一个将事件中的 Integer 对象转换成 String 的例子，仅供参考：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">observable.lift(<span class="keyword">new</span> Observable.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; call(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// 将事件序列中的 Integer 对象转换为 String 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                subscriber.onNext(<span class="string">""</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>讲述 lift() 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 lift() 的原理，RxJava 都不建议开发者自定义 Operator 来直接使用 lift()，而是建议尽量使用已有的 lift() 包装方法（如 map() flatMap() 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。</p>
</blockquote>
<h4 id="4-3-compose-对-Observable-整体的变换"><a href="#4-3-compose-对-Observable-整体的变换" class="headerlink" title="4.3 compose: 对 Observable 整体的变换"></a>4.3 compose: 对 Observable 整体的变换</h4><p>除了 lift() 之外， Observable 还有一个变换方法叫做 compose(Transformer)。它和 lift() 的区别在于， lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。举个例子，假设在程序中有多个 Observable ，并且他们都需要应用一组相同的 lift() 变换。你可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">observable1</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br><span class="line">observable2</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber2);</span><br><span class="line">observable3</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber3);</span><br><span class="line">observable4</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<p>也可以改成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Observable <span class="title">liftAll</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observable</span><br><span class="line">        .lift1()</span><br><span class="line">        .lift2()</span><br><span class="line">        .lift3()</span><br><span class="line">        .lift4();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">liftAll(observable1).subscribe(subscriber1);</span><br><span class="line">liftAll(observable2).subscribe(subscriber2);</span><br><span class="line">liftAll(observable3).subscribe(subscriber3);</span><br><span class="line">liftAll(observable4).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<p>可读性、可维护性都提高了。可是 Observable 被一个方法包起来，这种方式对于 Observale 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 compose() 来解决了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftAllTransformer</span> <span class="keyword">implements</span> <span class="title">Observable</span>.<span class="title">Transformer</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(Observable&lt;Integer&gt; observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Transformer liftAll = <span class="keyword">new</span> LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure>
<p>像上面这样，使用 compose() 方法，Observable 可以利用传入的 Transformer 对象的 call 方法直接对自身进行处理，也就不必被包在方法的里面了。</p>
<h3 id="5-线程控制：Scheduler"><a href="#5-线程控制：Scheduler" class="headerlink" title="5. 线程控制：Scheduler"></a>5. 线程控制：Scheduler</h3><p>除了灵活的变换，RxJava 另一个强大的地方，就是线程的自由控制。</p>
<h4 id="5-1-Scheduler的API"><a href="#5-1-Scheduler的API" class="headerlink" title="5.1 Scheduler的API"></a>5.1 Scheduler的API</h4><p>前面讲到了，可以利用 subscribeOn() 结合 observeOn() 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 map() flatMap() 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p>
<p>答案是：能。因为 observeOn() 指定的是 Subscriber 的线程，而这个 Subscriber 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）subscribe() 参数中的 Subscriber ，而是 observeOn() 执行时的当前 Observable 所对应的 Subscriber ，即它的直接下级 Subscriber 。换句话说，observeOn() 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 observeOn() 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure>
<p>如上，通过 observeOn() 的多次调用，程序实现了线程的多次切换。</p>
<h4 id="5-2-Scheduler的原理"><a href="#5-2-Scheduler的原理" class="headerlink" title="5.2 Scheduler的原理"></a>5.2 Scheduler的原理</h4><p>其实， subscribeOn() 和 observeOn() 的内部实现，也是用的 lift()。具体看图（不同颜色的箭头表示不同的线程）：</p>
<p>subscribeOn() 原理图：</p>
<p><img src="E:\资料库\工作资料\随笔记录\杂货铺\subscribe-on.jpg" alt="subscribe-on"></p>
<p>observeOn() 原理图：</p>
<p><img src="E:\资料库\工作资料\随笔记录\杂货铺\observe-on.jpg" alt="observe-on"></p>
<p>从图中可以看出，subscribeOn() 和 observeOn() 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， subscribeOn() 的线程切换发生在 OnSubscribe 中，即在它通知上一级 OnSubscribe 时，这时事件还没有开始发送，因此 subscribeOn() 的线程控制可以从事件发出的开端就造成影响；而 observeOn() 的线程切换则发生在它内建的 Subscriber 中，即发生在它即将给下一级 Subscriber 发送事件时，因此 observeOn() 控制的是它后面的线程。</p>
<p>最后，我用一张图来解释当多个 subscribeOn() 和 observeOn() 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：</p>
<p><img src="E:\资料库\工作资料\随笔记录\杂货铺\complex-scheduler.jpg" alt="complex-scheduler"></p>
<p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 subscribeOn() 影响，运行在红色线程；③和④处受第一个 observeOn() 的影响，运行在绿色线程；⑤处受第二个 onserveOn() 影响，运行在紫色线程；而第二个 subscribeOn() ，由于在通知过程中线程就被第一个 subscribeOn() 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 subscribeOn() 的时候，只有第一个 subscribeOn() 起作用。</p>
<h4 id="5-3-延伸：doOnSubscribe"><a href="#5-3-延伸：doOnSubscribe" class="headerlink" title="5.3 延伸：doOnSubscribe()"></a>5.3 延伸：doOnSubscribe()</h4><p>然而，虽然超过一个的 subscribeOn() 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p>
<p>在前面讲 Subscriber 的时候，提到过 Subscriber 的 onStart() 可以用作流程开始前的初始化。然而 onStart() 由于在 subscribe() 发生时就被调用了，因此不能指定线程，而是只能执行在 subscribe() 被调用时的线程。这就导致如果 onStart() 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 subscribe() 将会在什么线程执行。</p>
<p>而与 Subscriber.onStart() 相对应的，有一个方法 Observable.doOnSubscribe() 。它和 Subscriber.onStart() 同样是在 subscribe() 调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， doOnSubscribe() 执行在 subscribe() 发生的线程；而如果在 doOnSubscribe() 之后有 subscribeOn() 的话，它将执行在离它最近的 subscribeOn() 所指定的线程。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); <span class="comment">// 需要在主线程执行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) <span class="comment">// 指定主线程</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>如上，在 doOnSubscribe()的后面跟一个 subscribeOn() ，就能指定准备工作的线程了。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/软件开发/">软件开发</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://yoursite.com/2018/05/13/RxJava入门介绍/" data-title="RxJava入门介绍 | 秋日私语" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2018/05/23/问题记录框架/" title="问题记录框架">
  <strong>上一篇：</strong><br/>
  <span>
  问题记录框架</span>
</a>
</div>


<div class="next">
<a href="/2018/04/20/软件开发阅读书目/"  title="软件开发阅读书目">
 <strong>下一篇：</strong><br/> 
 <span>软件开发阅读书目
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API-介绍和原理简析"><span class="toc-number">2.</span> <span class="toc-text">API 介绍和原理简析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-概念：扩展的观察者模式"><span class="toc-number">2.1.</span> <span class="toc-text">1.  概念：扩展的观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-基本实现"><span class="toc-number">2.2.</span> <span class="toc-text">2. 基本实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-创建-Observer"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.1 创建 Observer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-创建-Observable"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2 创建 Observable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-Subscribe-订阅"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.3 Subscribe (订阅)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-使用示例"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.4 使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程控制-Scheduler"><span class="toc-number">2.3.</span> <span class="toc-text">3. 线程控制(Scheduler)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Scheduler-的-API"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 Scheduler 的 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Scheduler的原理"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 Scheduler的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-变换"><span class="toc-number">2.4.</span> <span class="toc-text">4.变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-API"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-变换的原理-lift"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 变换的原理(lift)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-compose-对-Observable-整体的变换"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 compose: 对 Observable 整体的变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-线程控制：Scheduler"><span class="toc-number">2.5.</span> <span class="toc-text">5. 线程控制：Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-Scheduler的API"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 Scheduler的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Scheduler的原理"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 Scheduler的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-延伸：doOnSubscribe"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3 延伸：doOnSubscribe()</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/软件开发/" title="软件开发">软件开发<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/思维/" title="思维">思维<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/高效学习/" title="高效学习">高效学习<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/开发工具/" title="开发工具">开发工具<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/网站/" title="网站">网站<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/经验/" title="经验">经验<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/baoxielin/" target="_blank" title="我的GitHub主页">Github</a>
            
          </li>
        
          <li>
            
            	<a href="https://toutiao.io/" target="_blank" title="程序员首选阅读分享平台">开发者头条</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.jobbole.com/" target="_blank" title="专注于分享IT互联网相关的文章">伯乐在线</a>
            
          </li>
        
          <li>
            
            	<a href="https://juejin.im/" target="_blank" title="高质量的技术社区">稀土掘金</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.android-studio.org/" target="_blank" title="AndroidStudio中文社区">AndroidStudio中文社区</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.oschina.net/" target="_blank" title="开源中国社区">开源中国社区</a>
            
          </li>
        
          <li>
            
            	<a href="https://martinfowler.com/" target="_blank" title="MartinFlower">MartinFlower</a>
            
          </li>
        
          <li>
            
            	<a href="https://coolshell.cn/" target="_blank" title="酷壳">酷壳</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.luanxiang.org/" target="_blank" title="乱象，印迹">乱象，印迹</a>
            
          </li>
        
          <li>
            
            	<a href="https://blog.csdn.net/guolin_blog/" target="_blank" title="郭霖专栏">郭霖专栏</a>
            
          </li>
        
          <li>
            
            	<a href="https://blog.csdn.net/xlgen157387" target="_blank" title="徐刘根的博客">徐刘根的博客</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.liaoxuefeng.com/" target="_blank" title="廖雪峰的官方网站">廖雪峰的官方网站</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.buzzfeed.com/" target="_blank" title="BuzzFeeD">BuzzFeeD</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="秋日私语">秋日私语</a>
		
		</p>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<span id="busuanzi_container_site_pv">
    &nbsp;&nbsp;Total visits:&nbsp;<span id="busuanzi_value_site_pv"></span>
</span>
<span id="busuanzi_container_site_uv">
  &nbsp;&nbsp;You are Visiter No.<span id="busuanzi_value_site_uv"></span>
</span></footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
